%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{MetaNN}
\date{Jun 13, 2019}
\release{0.1.2}
\author{Hanqiao Yu}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{MetaNN for PyTorch Meta Learning}
\label{\detokenize{readme_link:metann-for-pytorch-meta-learning}}\label{\detokenize{readme_link::doc}}

\section{1. Introduction}
\label{\detokenize{readme_link:introduction}}
In meta learner scenario, it is common use dependent variables as parameters, and back propagate the gradient of the parameters. However, parameters of PyTorch Module are designed to be leaf nodes and it is forbidden for parameters to have grad\_fn. Meta learning coders are therefore forced to rewrite the basic layers to adapt the meta learning requirements.

This module provide an extension of torch.nn.Module, DependentModule that has dependent parameters, allowing the differentiable dependent parameters. It also provide the method to transform nn.Module into DependentModule, and turning all of the parameters of a nn.Module into dependent parameters.


\section{2. Installation}
\label{\detokenize{readme_link:installation}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pip} \PYG{n}{install} \PYG{n}{MetaNN}
\end{sphinxVerbatim}


\section{3. Example}
\label{\detokenize{readme_link:example}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{metann} \PYG{k}{import} \PYG{n}{DependentModule}\PYG{p}{,} \PYG{n}{Learner}
\PYG{k+kn}{from} \PYG{n+nn}{torch} \PYG{k}{import} \PYG{n}{nn}
\PYG{n}{net} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{nn}\PYG{o}{.}\PYG{n}{Sequential}\PYG{p}{(}
    \PYG{n}{nn}\PYG{o}{.}\PYG{n}{Linear}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{nn}\PYG{o}{.}\PYG{n}{Linear}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{net} \PYG{o}{=} \PYG{n}{DependentModule}\PYG{p}{(}\PYG{n}{net}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{net}\PYG{p}{)}
\end{sphinxVerbatim}


\section{4. Documents}
\label{\detokenize{readme_link:documents}}
\sphinxhref{https://metann.readthedocs.io/}{MetaNN}

This won’t build correctly with the heavy dependency PyTorch, so I updated the sphinx built html to GitHub. I hate to use mock to solve This problem, I suggest you to clone the repository and view the html docs yourself.


\section{5. License}
\label{\detokenize{readme_link:license}}
\sphinxhref{http://opensource.org/licenses/MIT}{MIT}

Copyright (c) 2019-present, Hanqiao Yu


\chapter{metann package}
\label{\detokenize{metann:metann-package}}\label{\detokenize{metann::doc}}

\section{Module contents}
\label{\detokenize{metann:module-metann}}\label{\detokenize{metann:module-contents}}\index{metann (module)@\spxentry{metann}\spxextra{module}}\index{DependentModule (class in metann)@\spxentry{DependentModule}\spxextra{class in metann}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{metann:metann.DependentModule}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{metann.}}\sphinxbfcode{\sphinxupquote{DependentModule}}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \sphinxcode{\sphinxupquote{torch.nn.modules.module.Module}}

This module provides an extension to nn.Module by add a subset to buffers, dependents. They are similar to parameter,
but they are registered in buffers, so that they can have grad\_fn.
This module calls DependentModule.to\_dependentmodule when it is created. It turns the module and all of its
submodules into sub class of DependentModule

Examples:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}net = Sequential(Linear(10, 5), Linear(5, 2))}
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}DependentModule(net)}
\PYG{g+go}{DependentSequential(}
\PYG{g+go}{  (0): DependentLinear(in\PYGZus{}features=10, out\PYGZus{}features=5, bias=True)}
\PYG{g+go}{  (1): DependentLinear(in\PYGZus{}features=5, out\PYGZus{}features=2, bias=True)}
\PYG{g+go}{)}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
This class change the origin module when initializing, you might use

\textgreater{}\textgreater{}\textgreater{}DependentModule(deepcopy(net))

if you want the origin model stay unchanged.
\end{sphinxadmonition}
\index{clear\_params() (metann.DependentModule method)@\spxentry{clear\_params()}\spxextra{metann.DependentModule method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{metann:metann.DependentModule.clear_params}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{clear\_params}}}{\emph{init=False}, \emph{clear\_filter=\textless{}function DependentModule.\textless{}lambda\textgreater{}\textgreater{}}}{}
Clear all parameters of self and register them as dependents.
:param init: Set the values of dependents to None if set to False, otherwise keep the value of origin parameters.
:param clear\_filter: Function that return False when those modules you don’t want to clear parameters are input

\end{fulllineitems}

\index{dependents() (metann.DependentModule method)@\spxentry{dependents()}\spxextra{metann.DependentModule method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{metann:metann.DependentModule.dependents}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dependents}}}{\emph{recurse=True}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{recurse}} \textendash{} traverse only the direct submodules of self if set to False

\item[{Returns}] \leavevmode
iterator of dependents of self and sub modules.

\end{description}\end{quote}

\end{fulllineitems}

\index{named\_dependents() (metann.DependentModule method)@\spxentry{named\_dependents()}\spxextra{metann.DependentModule method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{metann:metann.DependentModule.named_dependents}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{named\_dependents}}}{\emph{prefix=''}, \emph{recurse=True}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{prefix}} \textendash{} the prefix of the names

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{recurse}} \textendash{} traverse only the direct submodules of self if set to False

\end{itemize}

\item[{Returns}] \leavevmode
iterator of name, dependent pairs of self and sub modules.

\end{description}\end{quote}

\end{fulllineitems}

\index{register\_dependent() (metann.DependentModule method)@\spxentry{register\_dependent()}\spxextra{metann.DependentModule method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{metann:metann.DependentModule.register_dependent}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{register\_dependent}}}{\emph{name}, \emph{tensor}}{}
register a named tensor to dependents.
:param name: name of dependent
:param tensor:

Examples:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}dnet = DependentModule(net)}
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}dnet.register\PYGZus{}dependent(\PYGZsq{}some\PYGZus{}tensor\PYGZsq{}, torch.randn(3, 3))}
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}dnet.some\PYGZus{}tensor}
\PYG{g+go}{tensor([[ 0.4434,  0.9949, \PYGZhy{}0.4385],}
\PYG{g+go}{        [\PYGZhy{}0.5292,  0.2555,  0.7772],}
\PYG{g+go}{        [\PYGZhy{}0.5386,  0.6152, \PYGZhy{}0.3239]])}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{stateless() (metann.DependentModule class method)@\spxentry{stateless()}\spxextra{metann.DependentModule class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{metann:metann.DependentModule.stateless}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{stateless}}}{\emph{module: torch.nn.modules.module.Module}, \emph{clear\_filter=\textless{}function DependentModule.\textless{}lambda\textgreater{}\textgreater{}}}{}
transform input module into a DependentModule whose parameters are cleared.
:param module:
:param clear\_filter:

\end{fulllineitems}

\index{substitute() (metann.DependentModule method)@\spxentry{substitute()}\spxextra{metann.DependentModule method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{metann:metann.DependentModule.substitute}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{substitute}}}{\emph{named\_params}, \emph{strict=True}}{}
Substitute self’s dependents with the tensors of same name
:param named\_params: iterator of name, tensor pairs
:param strict: forbid named\_params and self.\_dependents mismatch if set to True. default: True

\end{fulllineitems}

\index{substitute\_from\_list() (metann.DependentModule method)@\spxentry{substitute\_from\_list()}\spxextra{metann.DependentModule method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{metann:metann.DependentModule.substitute_from_list}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{substitute\_from\_list}}}{\emph{params}}{}
Substitute from tensor list.
:param params: iterator of tensors

\end{fulllineitems}

\index{to\_dependentmodule() (metann.DependentModule class method)@\spxentry{to\_dependentmodule()}\spxextra{metann.DependentModule class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{metann:metann.DependentModule.to_dependentmodule}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{to\_dependentmodule}}}{\emph{module: torch.nn.modules.module.Module}, \emph{recurse=True}}{}
\end{fulllineitems}

\index{update\_shapes() (metann.DependentModule method)@\spxentry{update\_shapes()}\spxextra{metann.DependentModule method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{metann:metann.DependentModule.update_shapes}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{update\_shapes}}}{}{}
update the register shape of dependents. Call this method when a dependent is initialize with None and assign
to a tensor. \sphinxstylestrong{Do not} call this method when you are using built-in methods only.
:return:

\end{fulllineitems}


\end{fulllineitems}

\index{Learner (class in metann)@\spxentry{Learner}\spxextra{class in metann}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{metann:metann.Learner}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{metann.}}\sphinxbfcode{\sphinxupquote{Learner}}}{\emph{module: torch.nn.modules.module.Module}}{}
Bases: \sphinxcode{\sphinxupquote{torch.nn.modules.module.Module}}

This module extends nn.Module by providing functional method.
:param module: a nn.Module module
\index{functional() (metann.Learner method)@\spxentry{functional()}\spxextra{metann.Learner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{metann:metann.Learner.functional}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{functional}}}{\emph{params}, \emph{training}, \emph{*args}, \emph{**kwargs}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{params}} (\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}) \textendash{} input model parameters for functional

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{training}} \textendash{} if the functional set to trainning=True

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{args}} \textendash{} input

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{kwargs}} \textendash{} input

\end{itemize}

\item[{Returns}] \leavevmode
return the output of model

\end{description}\end{quote}

Examples:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}learner = Learner(net)}
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}outputs = learner.functional(net.parameters(), training=True, x)}
\end{sphinxVerbatim}

\end{fulllineitems}


\end{fulllineitems}



\section{Subpackages}
\label{\detokenize{metann:subpackages}}

\subsection{metann.utils package}
\label{\detokenize{metann.utils:metann-utils-package}}\label{\detokenize{metann.utils::doc}}

\subsubsection{Module contents}
\label{\detokenize{metann.utils:module-metann.utils}}\label{\detokenize{metann.utils:module-contents}}\index{metann.utils (module)@\spxentry{metann.utils}\spxextra{module}}\index{SubDict (class in metann.utils)@\spxentry{SubDict}\spxextra{class in metann.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{metann.utils:metann.utils.SubDict}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{metann.utils.}}\sphinxbfcode{\sphinxupquote{SubDict}}}{\emph{super\_dict: collections.abc.Mapping}, \emph{keys={[}{]}}, \emph{keep\_order=True}}{}
Bases: \sphinxcode{\sphinxupquote{collections.abc.MutableMapping}}

Provide a sub dict \sphinxstylestrong{access} to a super dict.
Parameters:
\begin{quote}
\begin{quote}\begin{description}
\item[{param super\_dict (Mapping)}] \leavevmode
The super dictionary where you want to take a sub dict

\item[{param keys (iterable)}] \leavevmode
An iterable of keys according to which you want to access a sub dict

\item[{param keep\_order (bool)}] \leavevmode
If set to true the sub dict will keep the iteration order of the super dict
when it is iterated. Default: True

\end{description}\end{quote}
\end{quote}

Examples:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}super\PYGZus{}dict = collections.OrderedDict(\PYGZob{}\PYGZsq{}a\PYGZsq{}: 1, \PYGZsq{}b\PYGZsq{}: 2, \PYGZsq{}c\PYGZsq{}: 3\PYGZcb{})}
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}sub\PYGZus{}dict = SubDict(super\PYGZus{}dict, keys=[\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}])}
\end{sphinxVerbatim}
\index{update\_keys() (metann.utils.SubDict method)@\spxentry{update\_keys()}\spxextra{metann.utils.SubDict method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{metann.utils:metann.utils.SubDict.update_keys}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{update\_keys}}}{}{}
This method update the keys of the sub dict when the super dict is modified.

\begin{sphinxadmonition}{note}{Note:}
\sphinxstylestrong{Do not} call this method when you use the built-in method only.
\end{sphinxadmonition}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{m}
\item\relax\sphinxstyleindexentry{metann}\sphinxstyleindexpageref{metann:\detokenize{module-metann}}
\item\relax\sphinxstyleindexentry{metann.utils}\sphinxstyleindexpageref{metann.utils:\detokenize{module-metann.utils}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}